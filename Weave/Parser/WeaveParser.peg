@namespace Weave.Parser
@classname WeaveParser
@using System.Linq
@using Weave.Expressions

template <Template>
    = settings:setting* EOL? elements:lines (EOF / unexpected:. #ERROR{ string.Format("Unexpected character '{0}'.", unexpected) }) {
        new Template(settings, settingsEnd, elements)
    }

setting <KeyValuePair<SourceSpan, SourceSpan>>
    = "@" key:identifier (!EOL WS)+ value:("" (!EOL .)+) (EOL / EOF) {
        new KeyValuePair<SourceSpan, SourceSpan>(
            new SourceSpan(key, keyStart, keyEnd),
            new SourceSpan(value, valueStart, valueEnd))
    }

lines <IList<Element>>
    = lines:line* { lines.SelectMany(l => l).ToList() }

line <IList<Element>>
    = t:tag { new[] { t } }
    / textLine

textLine <IList<Element>>
    = !EOF contents:inlineElement* end:(EOL / EOF) { contents.Concat(new[] { new TextElement(end) }).ToList() }

inlineContents <IList<Element>>
    = body:(<IEnumerable<Element>> first:textLine middle:lines { first.Concat(middle) })? rest:inlineElement* { body.SelectMany(b => b).Concat(rest).ToList() }

inlineElement <Element>
    = t:text                         { new TextElement(t)                }
    / "{{:" WS? expr:expression "}}" { new EchoTag(expr, encoded: true)  }
    / "{{=" WS? expr:expression "}}" { new EchoTag(expr, encoded: false) }
    / inlineCodeElement
    / inlineIfElement
    / inlineEachElement

tag <Element>
    = codeElement
    / ifElement
    / eachElement

codeElement <CodeElement>
    = (!EOL WS)* e:inlineCodeElement (!EOL WS)* (EOL / EOF) { e }

inlineCodeElement <CodeElement>
    = "{{" &WS expr:expression "}}"  { new CodeElement(expr) }

ifElement <IfElement>
    = if:ifBody elseIfs:elifBody* else:elseBody? (!EOL WS)* endIfTag (!EOL WS)* (EOL / EOF) {
        new IfElement(new[] { @if }.Concat(elseIfs).Concat(@else))
    }

ifBody <Branch>
    = (!EOL WS)* expr:ifTag   (!EOL WS)* EOL body:lines { new Branch(expr, body) }

elifBody <Branch>
    = (!EOL WS)* expr:elifTag (!EOL WS)* EOL body:lines { new Branch(expr, body) }

elseBody <Branch>
    = (!EOL WS)* elseTag      (!EOL WS)* EOL body:lines { new Branch(null, body) }

inlineIfElement <IfElement>
    = if:inlineIfBody elseIfs:inlineElifBody* else:inlineElseBody? endIfTag {
        new IfElement(new[] { @if }.Concat(elseIfs).Concat(@else))
    }

inlineIfBody <Branch>
    = expr:ifTag   body:inlineContents { new Branch(expr, body) }

inlineElifBody <Branch>
    = expr:elifTag body:inlineContents { new Branch(expr, body) }

inlineElseBody <Branch>
    = elseTag      body:inlineContents { new Branch(null, body) }

eachElement <EachElement>
    = each:eachBody none:noneBody? (!EOL WS)* endEachTag (!EOL WS)* (EOL / EOF) {
        new EachElement(each.Item1, each.Item2, none.SingleOrDefault())
    }

eachBody <Tuple<SourceSpan, IList<Element>>>
    = (!EOL WS)* expr:eachTag (!EOL WS)* EOL body:lines { Tuple.Create(expr, (IList<Element>)body) }

noneBody <IList<Element>>
    = (!EOL WS)* noneTag (!EOL WS)* EOL body:lines { body }

inlineEachElement <EachElement>
    = each:inlineEachBody none:inlineNoneBody? endEachTag {
        new EachElement(each.Item1, each.Item2, none.SingleOrDefault())
    }

inlineEachBody <Tuple<SourceSpan, IList<Element>>>
    = expr:eachTag body:inlineContents { Tuple.Create(expr, body) }

inlineNoneBody <IList<Element>>
    = noneTag body:inlineContents { body }

ifTag   <SourceSpan> = "{{if" &WS expr:expression "}}"   { expr }
elifTag <SourceSpan> = "{{elif" &WS expr:expression "}}" { expr }
elseTag              = "{{else}}"
endIfTag             = "{{/if}}"
eachTag <SourceSpan> = "{{each" &WS expr:expression "}}" { expr }
noneTag              = "{{none}}"
endEachTag           = "{{/each}}"

text -memoize
    = "" (!EOL !"{{" .)+

expression <SourceSpan>
    = text:("" (!"}}" .)+) { new SourceSpan(text, textStart, textEnd) }

identifier
    = !digit (letter / digit / "_" / "$")+

digit
  = [0-9]

letter
  = lowerCaseLetter
  / upperCaseLetter

lowerCaseLetter
  = [a-z]

upperCaseLetter
  = [A-Z]

WS
    = [ \t\v\f\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]
    / EOL

EOL
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

EOF
  = !.
