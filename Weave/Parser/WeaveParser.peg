@namespace Weave.Parser
@classname WeaveParser
@using System.Linq
@using Weave.Expressions
@members
{
    private class RenderTag
    {
        public SourceSpan Method { get; set; }
        public SourceSpan Expression { get; set; }
    }
}


template <Template>
    = settings:setting* EOL? elements:lines (EOF / unexpected:. #ERROR{ string.Format("Unexpected character '{0}'.", unexpected) }) {
        new Template(settings, settingsEnd, elements)
    }

setting <KeyValuePair<SourceSpan, SourceSpan>>
    = "@" key:identifier (!EOL WS)+ value:("" (!EOL .)+) (EOL / EOF) {
        new KeyValuePair<SourceSpan, SourceSpan>(
            key,
            new SourceSpan(value, valueStart, valueEnd))
    }

lines <IList<Element>>
    = lines:line* { lines.SelectMany(l => l).ToList() }

line <IList<Element>>
    = t:tag { new[] { t } }
    / textLine

textLine <IList<Element>>
    = !EOF indentation:(!EOL (!EOL WS)*)? contents:inlineElement* end:(EOL / EOF) {{
        var results = new List<Element>();
        results.AddRange(indentation.Select(i => new IndentationElement(i)));
        results.AddRange(contents);

        if (end != string.Empty)
        {
            results.Add(new NewLineElement());
        }

        return results;
    }}

inlineContents <IList<Element>>
    = body:(<IEnumerable<Element>> first:textLine middle:lines { first.Concat(middle) })? rest:inlineElement* { body.SelectMany(b => b).Concat(rest).ToList() }

inlineElement <Element>
    = t:text                         { new TextElement(t)                }
    / "{{:" WS? expr:expression "}}" { new EchoTag(expr, encoded: true)  }
    / "{{=" WS? expr:expression "}}" { new EchoTag(expr, encoded: false) }
    / inlineCodeElement
    / inlineIfElement
    / inlineEachElement
    / inlineRenderElement

tag <Element>
    = codeElement
    / ifElement
    / eachElement
    / renderElement

codeElement <CodeElement>
    = indentation:("" (!EOL WS)*) expr:codeTag (!EOL WS)* (EOL / EOF) { new CodeElement(expr, indentation) }

inlineCodeElement <CodeElement>
    = expr:codeTag  { new CodeElement(expr) }

ifElement <IfElement>
    = if:ifBody elseIfs:elifBody* else:elseBody? endIndentation:("" (!EOL WS)*) endIfTag (!EOL WS)* (EOL / EOF) {
        new IfElement(new[] { @if }.Concat(elseIfs).Concat(@else), endIndentation)
    }

ifBody <Branch>
    = indentation:("" (!EOL WS)*) expr:ifTag   (!EOL WS)* EOL body:lines { new Branch(expr, body, indentation) }

elifBody <Branch>
    = indentation:("" (!EOL WS)*) expr:elifTag (!EOL WS)* EOL body:lines { new Branch(expr, body, indentation) }

elseBody <Branch>
    = indentation:("" (!EOL WS)*) elseTag      (!EOL WS)* EOL body:lines { new Branch(null, body, indentation) }

inlineIfElement <IfElement>
    = if:inlineIfBody elseIfs:inlineElifBody* else:inlineElseBody? endIfTag {
        new IfElement(new[] { @if }.Concat(elseIfs).Concat(@else))
    }

inlineIfBody <Branch>
    = expr:ifTag   body:inlineContents { new Branch(expr, body) }

inlineElifBody <Branch>
    = expr:elifTag body:inlineContents { new Branch(expr, body) }

inlineElseBody <Branch>
    = elseTag      body:inlineContents { new Branch(null, body) }

eachElement <EachElement>
    = each:eachBody none:noneBody? endIndentation:("" (!EOL WS)*) endEachTag (!EOL WS)* (EOL / EOF) {
        new EachElement(@each, none.SingleOrDefault(), endIndentation)
    }

eachBody <EachBody>
    = indentation:("" (!EOL WS)*) expr:eachTag (!EOL WS)* EOL body:lines { new EachBody(expr, (IList<Element>)body, indentation) }

noneBody <NoneBody>
    = indentation:("" (!EOL WS)*) noneTag (!EOL WS)* EOL body:lines { new NoneBody(body, indentation) }

inlineEachElement <EachElement>
    = each:inlineEachBody none:inlineNoneBody? endEachTag {
        new EachElement(@each, none.SingleOrDefault())
    }

inlineEachBody <EachBody>
    = expr:eachTag body:inlineContents { new EachBody(expr, body) }

inlineNoneBody <NoneBody>
    = noneTag body:inlineContents { new NoneBody(body) }

renderElement <RenderElement>
    = indentation:("" (!EOL WS)*) tag:renderTag (!EOL WS)* (EOL / EOF) { new RenderElement(tag.Method, tag.Expression, indentation) }

inlineRenderElement <RenderElement>
    = tag:renderTag { new RenderElement(tag.Method, tag.Expression) }

codeTag <SourceSpan>  = "{{" &WS expr:expression "}}"                  { expr }
ifTag   <SourceSpan>  = "{{if" &WS expr:expression "}}"                { expr }
elifTag <SourceSpan>  = "{{elif" &WS expr:expression "}}"              { expr }
elseTag               = "{{else}}"
endIfTag              = "{{/if}}"
eachTag <SourceSpan>  = "{{each" &WS expr:expression "}}"              { expr }
noneTag               = "{{none}}"
endEachTag            = "{{/each}}"
renderTag <RenderTag> = "{{@" name:identifier &WS expr:expression "}}" { new RenderTag { Method = name, Expression = expr } }

text -memoize
    = "" (!EOL !"{{" .)+

expression <SourceSpan>
    = text:("" (!"}}" .)+) { new SourceSpan(text, textStart, textEnd) }

identifier <SourceSpan>
    = i:(!digit (letter / digit / "_" / "$")+) { new SourceSpan(i, iStart, iEnd) }

digit
  = [0-9]

letter
  = lowerCaseLetter
  / upperCaseLetter

lowerCaseLetter
  = [a-z]

upperCaseLetter
  = [A-Z]

WS
    = [ \t\v\f\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]
    / EOL

EOL
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

EOF
  = !.
